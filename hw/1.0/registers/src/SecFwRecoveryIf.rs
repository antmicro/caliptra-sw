// Licensed under the Apache-2.0 license.
//
// generated by caliptra_registers_generator with caliptra-rtl repo at 7c953512251707d6f77d7d9a2f6be186ed013d50
//
#![allow(clippy::erasing_op)]
#![allow(clippy::identity_op)]
/// A zero-sized type that represents ownership of this
/// peripheral, used to get access to a Register lock. Most
/// programs create one of these in unsafe code near the top of
/// main(), and pass it to the driver responsible for managing
/// all access to the hardware.
pub struct Secfwrecoveryif {
    _priv: (),
}
impl Secfwrecoveryif {
    pub const PTR: *mut u32 = 0x20004000 as *mut u32;
    /// # Safety
    ///
    /// Caller must ensure that all concurrent use of this
    /// peripheral in the firmware is done so in a compatible
    /// way. The simplest way to enforce this is to only call
    /// this function once.
    #[inline(always)]
    pub unsafe fn new() -> Self {
        Self { _priv: () }
    }
    /// Returns a register block that can be used to read
    /// registers from this peripheral, but cannot write.
    #[inline(always)]
    pub fn regs(&self) -> RegisterBlock<ureg::RealMmio> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
    /// Return a register block that can be used to read and
    /// write this peripheral's registers.
    #[inline(always)]
    pub fn regs_mut(&mut self) -> RegisterBlock<ureg::RealMmioMut> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
}
#[derive(Clone, Copy)]
pub struct RegisterBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio + core::default::Default> RegisterBlock<TMmio> {
    /// # Safety
    ///
    /// The caller is responsible for ensuring that ptr is valid for
    /// volatile reads and writes at any of the offsets in this register
    /// block.
    #[inline(always)]
    pub unsafe fn new(ptr: *mut u32) -> Self {
        Self {
            ptr,
            mmio: core::default::Default::default(),
        }
    }
}
impl<TMmio: ureg::Mmio> RegisterBlock<TMmio> {
    /// # Safety
    ///
    /// The caller is responsible for ensuring that ptr is valid for
    /// volatile reads and writes at any of the offsets in this register
    /// block.
    #[inline(always)]
    pub unsafe fn new_with_mmio(ptr: *mut u32, mmio: TMmio) -> Self {
        Self { ptr, mmio }
    }
    /// Read value: [`SecFwRecoveryIf::regs::ExtcapHeaderReadVal`]; Write value: [`SecFwRecoveryIf::regs::ExtcapHeaderWriteVal`]
    #[inline(always)]
    pub fn extcap_header(
        &self,
    ) -> ureg::RegRef<crate::SecFwRecoveryIf::meta::ExtcapHeader, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn prot_cap_0(&self) -> ureg::RegRef<crate::SecFwRecoveryIf::meta::ProtCap0, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn prot_cap_1(&self) -> ureg::RegRef<crate::SecFwRecoveryIf::meta::ProtCap1, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn prot_cap_2(&self) -> ureg::RegRef<crate::SecFwRecoveryIf::meta::ProtCap2, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xc / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn prot_cap_3(&self) -> ureg::RegRef<crate::SecFwRecoveryIf::meta::ProtCap3, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x10 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn device_id_0(&self) -> ureg::RegRef<crate::SecFwRecoveryIf::meta::DeviceId0, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x14 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn device_id_1(&self) -> ureg::RegRef<crate::SecFwRecoveryIf::meta::DeviceId1, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x18 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn device_id_2(&self) -> ureg::RegRef<crate::SecFwRecoveryIf::meta::DeviceId2, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x1c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn device_id_3(&self) -> ureg::RegRef<crate::SecFwRecoveryIf::meta::DeviceId3, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x20 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn device_id_4(&self) -> ureg::RegRef<crate::SecFwRecoveryIf::meta::DeviceId4, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x24 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn device_id_5(&self) -> ureg::RegRef<crate::SecFwRecoveryIf::meta::DeviceId5, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x28 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn device_id_6(&self) -> ureg::RegRef<crate::SecFwRecoveryIf::meta::DeviceId6, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x2c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn device_status_0(
        &self,
    ) -> ureg::RegRef<crate::SecFwRecoveryIf::meta::DeviceStatus0, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x30 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn device_status_1(
        &self,
    ) -> ureg::RegRef<crate::SecFwRecoveryIf::meta::DeviceStatus1, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x34 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn device_reset(&self) -> ureg::RegRef<crate::SecFwRecoveryIf::meta::DeviceReset, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x38 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn recovery_ctrl(
        &self,
    ) -> ureg::RegRef<crate::SecFwRecoveryIf::meta::RecoveryCtrl, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x3c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn recovery_status(
        &self,
    ) -> ureg::RegRef<crate::SecFwRecoveryIf::meta::RecoveryStatus, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x40 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn hw_status(&self) -> ureg::RegRef<crate::SecFwRecoveryIf::meta::HwStatus, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x44 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn indirect_fifo_ctrl_0(
        &self,
    ) -> ureg::RegRef<crate::SecFwRecoveryIf::meta::IndirectFifoCtrl0, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x48 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn indirect_fifo_ctrl_1(
        &self,
    ) -> ureg::RegRef<crate::SecFwRecoveryIf::meta::IndirectFifoCtrl1, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x4c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn indirect_fifo_status_0(
        &self,
    ) -> ureg::RegRef<crate::SecFwRecoveryIf::meta::IndirectFifoStatus0, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x50 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn indirect_fifo_status_1(
        &self,
    ) -> ureg::RegRef<crate::SecFwRecoveryIf::meta::IndirectFifoStatus1, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x54 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn indirect_fifo_status_2(
        &self,
    ) -> ureg::RegRef<crate::SecFwRecoveryIf::meta::IndirectFifoStatus2, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x58 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn indirect_fifo_status_3(
        &self,
    ) -> ureg::RegRef<crate::SecFwRecoveryIf::meta::IndirectFifoStatus3, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x5c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn indirect_fifo_status_4(
        &self,
    ) -> ureg::RegRef<crate::SecFwRecoveryIf::meta::IndirectFifoStatus4, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x60 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn indirect_fifo_status_5(
        &self,
    ) -> ureg::RegRef<crate::SecFwRecoveryIf::meta::IndirectFifoStatus5, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x64 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn indirect_fifo_data(
        &self,
    ) -> ureg::RegRef<crate::SecFwRecoveryIf::meta::IndirectFifoData, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x68 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
}
pub mod regs {
    //! Types that represent the values held by registers.
    #[derive(Clone, Copy)]
    pub struct ExtcapHeaderReadVal(u32);
    impl ExtcapHeaderReadVal {
        /// Capability Structure Length in DWORDs
        #[inline(always)]
        pub fn cap_length(&self) -> u32 {
            (self.0 >> 8) & 0xffff
        }
        /// Extended Capability ID
        #[inline(always)]
        pub fn cap_id(&self) -> u32 {
            (self.0 >> 0) & 0xff
        }
    }
    impl From<u32> for ExtcapHeaderReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ExtcapHeaderReadVal> for u32 {
        #[inline(always)]
        fn from(val: ExtcapHeaderReadVal) -> u32 {
            val.0
        }
    }
}
pub mod enums {
    //! Enumerations used by some register fields.
    pub mod selector {}
}
pub mod meta {
    //! Additional metadata needed by ureg.
    pub type ExtcapHeader = ureg::ReadOnlyReg32<crate::SecFwRecoveryIf::regs::ExtcapHeaderReadVal>;
    pub type ProtCap0 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type ProtCap1 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type ProtCap2 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type ProtCap3 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type DeviceId0 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type DeviceId1 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type DeviceId2 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type DeviceId3 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type DeviceId4 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type DeviceId5 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type DeviceId6 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type DeviceStatus0 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type DeviceStatus1 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type DeviceReset = ureg::ReadWriteReg32<0, u32, u32>;
    pub type RecoveryCtrl = ureg::ReadWriteReg32<0, u32, u32>;
    pub type RecoveryStatus = ureg::ReadWriteReg32<0, u32, u32>;
    pub type HwStatus = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IndirectFifoCtrl0 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IndirectFifoCtrl1 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IndirectFifoStatus0 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IndirectFifoStatus1 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IndirectFifoStatus2 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IndirectFifoStatus3 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IndirectFifoStatus4 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IndirectFifoStatus5 = ureg::ReadWriteReg32<0, u32, u32>;
    pub type IndirectFifoData = ureg::ReadWriteReg32<0, u32, u32>;
}
